-- Disable RLS temporarily if needed for schema changes by superuser, though ALTER TABLE usually doesn't require it.
-- SET session_replication_role = replica;

-- Step 1: Rename 'apps' to 'zirospace_apps' and update its dependent foreign keys.
DO $$
DECLARE
    fk_record RECORD;
BEGIN
    -- Update FK in public.screenshots referencing 'apps'
    FOR fk_record IN
        SELECT conname, conrelid::regclass::text as dependent_table
        FROM pg_constraint
        WHERE confrelid = 'public.apps'::regclass AND contype = 'f' AND conrelid = 'public.screenshots'::regclass
    LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(fk_record.dependent_table) || ' DROP CONSTRAINT ' || quote_ident(fk_record.conname);
    END LOOP;

    -- Update FK in public.app_ratings referencing 'apps'
    FOR fk_record IN
        SELECT conname, conrelid::regclass::text as dependent_table
        FROM pg_constraint
        WHERE confrelid = 'public.apps'::regclass AND contype = 'f' AND conrelid = 'public.app_ratings'::regclass
    LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(fk_record.dependent_table) || ' DROP CONSTRAINT ' || quote_ident(fk_record.conname);
    END LOOP;

    -- If 'app_tags' table exists and references 'apps' (from a previous migration attempt perhaps)
    IF EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'app_tags') THEN
        FOR fk_record IN
            SELECT conname, conrelid::regclass::text as dependent_table
            FROM pg_constraint
            WHERE confrelid = 'public.apps'::regclass AND contype = 'f' AND conrelid = 'public.app_tags'::regclass
        LOOP
            EXECUTE 'ALTER TABLE ' || quote_ident(fk_record.dependent_table) || ' DROP CONSTRAINT ' || quote_ident(fk_record.conname);
        END LOOP;
    END IF;
END;
$$;

-- Rename the apps table
ALTER TABLE IF EXISTS public.apps RENAME TO zirospace_apps;

-- Re-add FKs pointing to zirospace_apps
ALTER TABLE public.screenshots
    ADD CONSTRAINT screenshots_app_id_fkey FOREIGN KEY (app_id) REFERENCES public.zirospace_apps(id) ON DELETE CASCADE;

ALTER TABLE public.app_ratings
    ADD CONSTRAINT app_ratings_app_id_fkey FOREIGN KEY (app_id) REFERENCES public.zirospace_apps(id) ON DELETE CASCADE;


-- Step 2: Drop old tags and app_tags tables if they exist (from a previous un-prefixed migration e.g. 20250512162118_add_app_tags_tables.sql)
DROP TABLE IF EXISTS public.app_tags;
DROP TABLE IF EXISTS public.tags;

-- Step 3: Create 'zirospace_tags' table
CREATE TABLE public.zirospace_tags (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying NOT NULL UNIQUE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Step 4: Create 'zirospace_app_tags' linking table
CREATE TABLE public.zirospace_app_tags (
    app_id bigint NOT NULL,
    tag_id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT zirospace_app_tags_pkey PRIMARY KEY (app_id, tag_id),
    CONSTRAINT zirospace_app_tags_app_id_fkey FOREIGN KEY (app_id) REFERENCES public.zirospace_apps(id) ON DELETE CASCADE,
    CONSTRAINT zirospace_app_tags_tag_id_fkey FOREIGN KEY (tag_id) REFERENCES public.zirospace_tags(id) ON DELETE CASCADE
);

-- Step 5: Enable RLS and define policies for the new tables
ALTER TABLE public.zirospace_tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read access for zirospace_tags" ON public.zirospace_tags FOR SELECT USING (true);
-- Add policies for insert, update, delete for authenticated users or admins as needed
-- Example: CREATE POLICY "Admin can manage zirospace_tags" ON public.zirospace_tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');


ALTER TABLE public.zirospace_app_tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read access for zirospace_app_tags" ON public.zirospace_app_tags FOR SELECT USING (true);
-- Example: CREATE POLICY "Admin can manage zirospace_app_tags" ON public.zirospace_app_tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');


-- Step 6: Add a trigger to automatically update 'updated_at' timestamp on 'zirospace_tags'
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp_on_zirospace_tags_update
BEFORE UPDATE ON public.zirospace_tags
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- SET session_replication_role = DEFAULT;